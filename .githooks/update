#!/bin/sh
#
# An example hook script to block unannotated tags from entering.
# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
#
# To enable this hook, rename this file to "update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowmodifytag
#   This boolean sets whether a tag may be modified after creation. By default
#   it won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
# hooks.denycreatebranch
#   This boolean sets whether remotely creating branches will be denied
#   in the repository.  By default this is allowed.
#

# --- Command line#!/bin/bash
#
# An example hook script to create integrity Git type Change Package
# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
#
# To enable this hook, rename this file to "update".
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

#String pattern holding Integrity Item ID in commit message.
integrity_item_id="Integrity Item ID: "

#Only create Change Packages on specific acceptable branches return otherwise.
acceptable_branches="$(git config --get ptc.acceptablebranches)"
should_continue=$(echo "$acceptable_branches" | grep -w "$refname")
if [ -z "$should_continue" ]; then
  exit 0
fi

output_file="$(mktemp)"
url_pattern="$(git config --get ptc.urlpattern)"
url_search="<SHAID>"
is_bare_repo="$(git rev-parse --is-bare-repository)"
if [ "$is_bare_repo" = "true" ]; then
    repo="$(basename $PWD)"
else
    repolocation="$(dirname $PWD)"
    repo="$(basename $repolocation)"
fi

#get commit id list for the current push
zero="0000000000000000000000000000000000000000"
if [ "$oldrev" = "$zero" ]; then
#Incase of newly created branches
    hashIDS=$(git rev-list --reverse "$newrev" --not --branches=*)
else
    hashIDS=$(git rev-list --reverse --branches="$refname" "$oldrev..$newrev")
fi

hashIDarray=($hashIDS)
no_of_commits=${#hashIDarray[@]}
commit=0
output_file="$(mktemp)"

while [ "$commit" -lt "$no_of_commits" ];
do
    
    hashID=${hashIDarray[$commit]}
    #retrieve Item id from commit message
    IssueID=$(git show -s --format='%B' "$hashID" | grep "$integrity_item_id" |cut -d':' -f2)
    
    if [ "$IssueID" -eq "$IssueID" ] 2>/dev/null; then
    	IssueID=$((IssueID))
    else
        echo "ERROR: The commit message is not in the specified standard format " 1>&2
        rm -f "$output_file"
        exit 1
    fi
    
    #Item ID not found in commit messsage. Report error and exit.
    if [ "$IssueID" -lt 1 ]; then
        echo "ERROR: Integrity Item ID not found in commit message" 1>&2
        rm -f "$output_file"
        exit 1
    fi
    gitURL="${url_pattern//$url_search/$hashID}"

    memberList=$(git show --pretty="format:" --name-only "$hashID")
    memberStatusList=$(git show --pretty="format:" --name-status "$hashID"| cut -c1)
        
    author=$(git show -s --format='%ae' "$hashID"| cut -d@ -f1)
    date=$(git show -s --format='%ai' "$hashID")
    committer=$(git show -s --format='%ce' "$hashID"| cut -d@ -f1)
    cdate=$(git show -s --format='%ci' "$hashID")
    summary=$(git show -s --pretty="oneline" "$hashID" |cut -d' ' -f2,3-)
    commitFileListArray=($memberList)
    commitStatusListArray=($memberStatusList)
    no_of_members=${#commitFileListArray[@]}

    #Output change package info into file.
    echo "$IssueID" >> "$output_file"
    echo "$hashID" >> "$output_file"
    echo "$refname" >> "$output_file"
    echo "$author" >> "$output_file"
    echo "$date" >> "$output_file"
    echo "$committer" >> "$output_file"
    echo "$cdate" >> "$output_file"
    echo "$summary" >> "$output_file"
    echo "$gitURL" >> "$output_file"
    echo "$HOSTNAME" >> "$output_file"
    echo "$repo" >> "$output_file"
    echo "$no_of_members" >> "$output_file"
    member=0
    while [ "$member" -lt "$no_of_members" ];
    do
        memberName=${commitFileListArray[$member]}
        memberStatus=${commitStatusListArray[$member]}
        if [ "$memberStatus" == "D" ]; then
            memberHash="00000"
        else
            memberHash=$(git ls-tree "$hashID" "$memberName" | cut -d' ' -f3| cut -f1 )
        fi
        
        echo "$memberName" >> "$output_file"
        echo "$memberHash" >> "$output_file"
        echo "$memberStatus" >> "$output_file"
    	let member=$member+1
    done
    let commit=$commit+1
done

#Call to Integrity application to create and populate Change Package attributes/entries.
"$GIT_IM_INSTALL_DIR"/bin/CreateCP "$output_file"
if [ $? -ne 0 ]; then
    rm  "$output_file"
	exit 1 
fi
rm  "$output_file"
exit 0 

refname="$1"
oldrev="$2"
newrev="$3"

echo "inside update hook" >>updating.txt
# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." >&2
	echo " (if you want, you could supply GIT_DIR then run" >&2
	echo "  $0 <ref> <oldrev> <newrev>)" >&2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
	exit 1
fi

# --- Config
allowunannotated=$(git config --bool hooks.allowunannotated)
allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
denycreatebranch=$(git config --bool hooks.denycreatebranch)
allowdeletetag=$(git config --bool hooks.allowdeletetag)
allowmodifytag=$(git config --bool hooks.allowmodifytag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
case "$projectdesc" in
"Unnamed repository"* | "")
	echo "*** Project description file hasn't been set" >&2
	exit 1
	;;
esac

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
zero="0000000000000000000000000000000000000000"
if [ "$newrev" = "$zero" ]; then
	newrev_type=delete
else
	newrev_type=$(git cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
		then
			echo "*** Tag '$refname' already exists." >&2
			echo "*** Modifying a tag is not allowed in this repository." >&2
			exit 1
		fi
		;;
	refs/heads/*,commit)
		# branch
		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
			echo "*** Creating a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
		exit 1
		;;
esac
echo "exiting from update hook" >> updated.txt
# --- Finished
exit 0
